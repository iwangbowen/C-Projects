## gcc generate assembly code in intel syntax

gcc -c -S masm=intel test.c
char a[] = "abcdefg";
char *b = "abcdefg";

数组名a是一个指针常量，b是一个指针变量，程序会在栈上为b分配存储空间，但不会为a分配存储空间。

实际上，C代码翻译成汇编代码后，函数内的局部变量名都会被[EBP - 相应偏移量]替换。

而具有静态存储器的全局变量与此不同，变成汇编代码后，变成用.DATA指令来通过label来进行标示。

而函数内的局部变量变成汇编代码后，不需要通过label来标示，可以通过EBP来访问它们。

所以，函数内有多少局部变量，每个局部变量的大小，需要为局部变量在栈上分配多少存储空间，是在编译期间就已经确定的。

变量存取的相应汇编代码，就是通过减少EBP的值来访问不同的变量。（栈向下增长，EBP的值总是大于局部变量的地址）
在char a[] = "abcdefg"声明中，由于a是一个指针常量，所以a的值是确定的，所以程序中出现a[i]的地方都可以通过
[EBP - a相对于EBP的偏移量（常量，编译时确定）+ i * 数组元素的大小（编译时确定）]来替代，所以不需要单独的存储单元
来存储数组首个元素的地址，即a的值。

